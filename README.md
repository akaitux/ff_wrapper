# FF WRAPPER

Утилита для запуска ffmpeg. 


Перехватывает логи и записывает их в файлы с ротацией по времени или размеру.

Запускает в фоне "менеджера", который проверяет текущий статус кодирования и завершает его при заданных условиях.

Предназначена для запуске в контейнере как PID 1, но можно запускать и без.

Требования: python3.6+

### Алгоритмы менеджера

#### Проверка кодирования

При запуске менеджера запоминается текущий fps как базовый. Из него вычитается дельта и результирующее значение будет являться минимально возможными, ниже котого стрим будет считаться сбойным. Также проверяется текущая скорость в соответствии с заданным минимальным параметром. Если стартовая скорость ниже минимальной, то минимальная скорость будет равна <текущая скорость> - дельта. 

Если фпс и скорость ниже, чем их пороговые значения в течение n секунд - стрим считается сбойным и завершается. 

Если в stdout нет логов дольше, чем ENCODING_MAX_STDOUT_STUCK_TIME - процесс завершается. Проверка на зависание.


#### Проверка запущенного ffmpeg процесса

Менеджер постоянно проверяет текущий статус дочернего процесса ffmpeg если он завершился - убивает главный поток программы, что приводит к завершению с кодом 1.



## WORKDIR

У каждого враппера есть своя уникальная рабочая директория, в которой находятся логи, служебные файлы для чтения информации от процесса ffmpeg и текущий статус

`WORKDIR/pipes` - служебные pipes

`WORKDIR/logs` - логи

`WORKDIR/status` - текущий статус конфигурации

Если при запуске выясняется, что файл WORKDIR/status/PID существует и в системе запущен процесс с PID, который там содержится - программа завершится с ошибкой.

## Сигналы

SIGHUP - принудительная ротация логов

## Параметры 

Параметры задаются через переменные окружения:

### Общие параметры 
`WORKDIR` - по-ум. */tmp/ff_wrapper* - рабочая директория

`PROGRESS_BUFFER_LEN` - по-ум. *100000* - количество последних хранимых строк логов из -progress

`STDOUT_BUFFER_LEN` - по-ум. *100000* - количество последних хранимых строк логов из stdout

`NO_FILE_LOG` - по-ум. False - не писать файловые логи, для включения можно присвоить любую строку

`LOG_ROTATION_MODE` - по-ум. *days* - режим работы. days - ротация по дням, size - ротация по размеру

`LOG_ROTATION_DAYS` - по-ум. *1*  - как часто производить ротацию в режиме *days*

`LOG_ROTATION_MAX_KBYTES`  - по-ум. *25000* - максимальный размер файла логов в килобайтах в режиме *size*

`LOG_ROTATION_BACKUP` - по-ум. *5* - сколько последних файлов хранить

`IS_DEBUG` - по-ум. *False* - любое значение приведет к выводу debug логов

### Параметры менеджера

`MANAGER_START_DELAY` - по-ум. *5* - время в секундах, задержка перед стартом менеджера

`ENCODING_CHECK_START_DELAY` - по-ум. *55* - время в секундах, задержка перед стартом проверки кодирования

`ENCODING_DISABLE_CHECK` - по-ум. *False* - выключить проверку кодирования

`ENCODING_MIN_SPEED` - по-ум. *0.85* - значение скорости, ниже которого кодирование считается сбойным

`ENCODING_DELTA_FPS` - по-ум. *10* - значение fps, которое вычитается из базового значения fps. Если текущий fps кодирования ниже, чем эта разница, поток считается сбойным

`ENCODING_MAX_ERROR_TIME` - по-ум. *10* - время в секундах, сколько времени поток может быть статусе сбоя перед тем, как менеджер завершит кодирование и убьет сам себя

`ENCODING_MIN_BASE_FPS` - по-ум. *14* - Если базовый фпс (без дельты) ниже, чем это значение - стрим считается сбойным

`ENCODING_MAX_STDOUT_STUCK_TIME` - по-ум. *15* секунд - Если stdout не обновляется (ffmpeg завис) - через сколько секунд убить главный процесс

## API

`/last_progress` - получить последние логи из -progress.

`/last_stdout` - логи из stdout

Эти два запроса поддерживают следующие GET Парметры:
 
    `count` - по-ум. 20, колчиество последних строк. 0 - получить все доступные логи

    `json` - вернуть как json



 `/start_time` - время старта трансляции

`/cmd` - аргументы запуска

`/get_pid` - получить pid главного процесса (враппера)

`/get_ffmpeg_pid` - pid ffmpeg


# Запуск

Производится через ff_wrapper/main.py. Поддерживается python3.6+, дополнительные зависимости не требуются